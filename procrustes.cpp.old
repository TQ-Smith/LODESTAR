//
// File: procrustes.cpp
// Started: 30 Janurary 2023
// Author: TQ Smith
// Principle Investigator: Dr. Zachary Szpiech
// Purpose: Perform Procrustes Analysis from two real, symmetric
//              matrices in dimension k.
//

// Used for input and output.
#include <iostream>

// Used for basic math operatons.
#include <cmath>

// Used for random numbers.
#include <cstdlib>

// Used to seed the random number generator.
#include <ctime>

// Used in QR algorithm to get double EPS.
#include <limits>

// Unless otherwise specified, our streams come from std.
using namespace std;

//////////////////////////////////////////////////////////////////////////////////////

// Performs PCA on a real, symmetric matrix.
//  In this application, this is a distance matrix.
//  NOTE: This method should be modified to accept the needed temporary memory
//          since allocation for large matrices could be time consuming.
// Accepts:
//  double** X -> Our n x n distance matrix with 1s on the diagonal.
//  int n -> The dimension of n.
//  int k -> The dimension of the reduced data.
//      Assume 0 < k < n.
// Return: double**, A n x k matrix representing the reduction of X
//          into dimension k. 
double** distance_matrix_pca(double** X, int n, int k) {

    // Allocate all of the additional memory.

    // Used to compute Z^TZ, and then, hold the eigenvectors.
    double** eigvecs = create_real_matrix(n, n);

    // d and e used in eigenvector calculation.

    // Holds eigenvalues.
    double* d = new double[n];

    // Used as auxilary vector in tped2 and tqli.
    double* e = new double[n];

    // Used to hold means of columns.
    double* m = new double[n];

    // Allocate our set of points to return.
    double** points = create_real_matrix(n, k);

    // Calculate mean of each column of the matrix.
    for (int i = 0; i < n; i++) {
        m[i] = 0;
        // Calculate mean.
        for (int j = 0; j < n; j++) {
            m[i] += X[j][i];
        }
        m[i] /= n;
    }

    // Calculate Z^TZ.
    for (int a = 0; a < n; a++) {
        for (int b = 0; b < n; b++) {
            eigvecs[a][b] = 0;
            for (int c = 0; c < n; c++) {
                eigvecs[a][b] += (X[c][a] - m[a]) * (X[c][b] - m[b]);
            }
            eigvecs[a][b] /= (n - 1);
        }
    }

    // Now, calculate the eigenvalues.
    tred2(eigvecs, d, e, n, true);
    tqli(eigvecs, d, e, n, true);
    eigsrt(eigvecs, d, n);

    // Calculate projections in dimension k.
    for (int a = 0; a < n; a++) {
        for (int b = 0; b < k; b++) {
            points[a][b] = 0;
            for (int c = 0; c < n; c++) {
                points[a][b] += (X[a][c] - m[c]) * eigvecs[c][b];
            }
        }
    }

    // Free all allocated memory.
    destroy_real_matrix(eigvecs, n, n);
    delete [] d;
    delete [] e;
    delete [] m;

    // Return the points.
    return points;

}

//////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////// PROCRUSTES ANALYSIS //////////////////////////////////

// Perform Procrustes Analysis on two sets of points.
// Each set of points are stored in a n x k matrix where
//  there are n k-dimensional points. We assume there are 
//  no duplicate points.
// Accepts:
//  double** Xc -> The first centered set of points.
//  double** Yc -> The second centered set of points.
//  double** temp1 -> A k x k matrix used as a temp variable.
//  double** temp2 -> A k x k matrix used as a temp variable.
//  int n -> The number of points.
//  int k -> The dimension of each point.
//      Assumes 0 < k < n.
// Returns: double, The Procrustes statistic.
double procrustes_statistic(double** Xc, double** Yc, double** temp1, double** temp2, int n, int k) {


    // Next, we calculate the trace of XT_cX_c and YT_cY_c
    //  as described in the paper.
    double trX = 0;
    double trY = 0;

    // The trace is only the diagonal.
    //  We are taking the dot-product of each column
    //  with its opposing column.
    for (int i = 0; i < k; i++) {
        for (int j = 0; j < n; j++) {
            trX += (Xc[j][i]) * (Xc[j][i]);
            trY += (Yc[j][i]) * (Yc[j][i]); 
        }
    }

    // The hard part. Calculating tr(Lambda).
    double trLambda = 0;

    // We use our temp matrices in the calculation of 
    //  of C^TC for our SVD. We do not use a matrix 
    //  multiplicaiton routine because this is faster
    //  than generating transposes.

    // Used as a place holder in matrix multiplication.
    double dot;

    // First, calculate C = Y_c^TX_c and store in temp1.
    for (int a = 0; a < k; a++) {
        for (int b = 0; b < k; b++) {
            dot = 0;
            for (int c = 0; c < n; c++) {
                dot += (Yc[c][a]) * (Xc[c][b]);
            }
            temp1[a][b] = dot;
        }
    }

    // Next, we calculate C^TC.
    for (int a = 0; a < k; a++) {
        for (int b = 0; b < k; b++) {
            temp2[a][b] = 0;
            for (int c = 0; c < k; c++) {
                temp2[a][b] += temp1[c][a] * temp1[c][b];
            }
        }
    }

    // Finally, we need to eigenvalues of
    //  C^TC. If k = 1, 2, 3, this is easy
    //  otherwise we use the QR algorithm.

    // If C is a 1 x 1, then that is the singular value.
    if (k == 1) {

        trLambda = sqrt(temp2[0][0]);

    // If C is a 2 x 2, then we directly solve with the quadratic formula.
    } else if (k == 2) {

        // From Numeric Recipes in C.

        // Create the coefficients of the quadratic and the determinant.
        // Our quadratic is in the form of x^2+bx+c.
        double b = -(temp2[0][0] + temp2[1][1]);
        double c = (temp2[0][0] * temp2[1][1]) - (temp2[0][1] * temp2[1][0]);
        double det = sqrt(b * b - 4 * c);

        // Calculate q.
        double q = b < 0 ? -0.5 * (b - det) : -0.5 * (b + det);

        // Calculate trace.
        trLambda += sqrt(q) + sqrt(c / q);
    
    // If C is a 3 x 3, then we directly solve with the cubic formula
    // by the method of Francois Viete.
    } else if (k == 3) {

        // From Numeric Recipes in C.

        // Our cubic is in the form of x^3+ax^2+bx+c.
        // We are using the trace formula for the characteristic polynomial.

        // Calculate our coefficients.
        double a = -(temp2[0][0] + temp2[1][1] + temp2[2][2]);

        // Sum of minors along the diagonal.
        double b = ((temp2[1][1] * temp2[2][2]) - (temp2[1][2] * temp2[2][1]))
                    + ((temp2[0][0] * temp2[2][2]) - (temp2[0][2] * temp2[2][0]))
                    + ((temp2[0][0] * temp2[1][1]) - (temp2[0][1] * temp2[1][0]));

        // -detA
        double c = -(temp2[0][0] * ((temp2[1][1] * temp2[2][2]) - (temp2[2][1] * temp2[1][2])) 
                    - temp2[0][1] * ((temp2[1][0] * temp2[2][2]) - (temp2[1][2] * temp2[2][0])) 
                    + temp2[0][2] * ((temp2[1][0] * temp2[2][1]) - (temp2[1][1] * temp2[2][0])));

        // Now, we solve the cubic.
        double Q = (a * a - 3 * b) / 9;
        double R = (2 * a * a * a - 9 * a * b + 27 * c) / 54;
        double theta = acos(R / sqrt(Q * Q * Q));

        // Now calculate the sume of the roots.
        trLambda += sqrt(-2 * sqrt(Q) * cos(theta / 3) - (a/3));
        trLambda += sqrt(-2 * sqrt(Q) * cos((theta + 2 * M_PI) / 3) - (a/3));
        trLambda += sqrt(-2 * sqrt(Q) * cos((theta - 2 * M_PI) / 3) - (a/3));
        //printf("%lf\n", -2 * sqrt(Q) * cos(theta / 3) - (a/3));
        //printf("%lf\n", -2 * sqrt(Q) * cos((theta + 2 * M_PI) / 3) - (a/3));
        //printf("%lf\n", -2 * sqrt(Q) * cos((theta - 2 * M_PI) / 3) - (a/3));
        //printf("%lf\n", trLambda);

    } else {

        // We can clobber temp1 and use the rows of temp2 as d and e.
        //  We do not care about the eigenvectors or sorting.
        tred2(temp2, temp1[0], temp1[1], k, false);
        tqli(temp2, temp1[0], temp1[1], k, false);

        // Now, we add up the singular values.
        //  They are stored in temp1[0].
        for (int i = 0; i < k; i++) {
            trLambda += sqrt(temp1[0][i]);
        }

    }

    // Finally, we compute D(X, Y).
    return  1 - (trLambda * trLambda) / (trX * trY);
}

// A wrapper function for procrustes_statistic that 
//  preforms procrustes analysis between two sets
//  of points.
// Accepts:
//  double** X -> The first set of points.
//  double** Y -> The second set of points.
//  int n -> The number of points.
//  int k -> The dimension of each point.
//      Assumes 0 < k < n.
// Returns: double, The Procrustes statistic.
double procrustes_analysis(double** X, double** Y, int n, int k) {

    // Create our two temp matrices.
    double** temp1 = create_real_matrix(k, k);
    double** temp2 = create_real_matrix(k, k);

    // We first calculate x_0 and y_0.
    //  Each are of dimension k.
    double* x_0 = new double[k];
    double* y_0 = new double[k];

    // Note, the centering of the values could
    //  be its own function. But, we can center both
    //  sets together, and the code is only used twice.
    //  For those two reasons, we keep everything as is.

    // Set each element equal to 0.
    for (int i = 0; i < k; i++) {
        x_0[i] = 0;
        y_0[i] = 0;
    }
    // Now, calculate the center.
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < k; j++) {
            x_0[j] += (X[i][j] / n);
            y_0[j] += (Y[i][j] / n);
        }
    }
    // Center the sets of points.
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < k; j++) {
            X[i][j] -= x_0[j];
            Y[i][j] -= y_0[j];
        }
    }

    // Calculate our statisitc.
    double stat = procrustes_statistic(X, Y, temp1, temp2, n, k);

    // Uncenter the points.
    //  This is only needed if we want X and Y unchanged.
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < k; j++) {
            X[i][j] += x_0[j];
            Y[i][j] += y_0[j];
        }
    }

    // Deallocate our temp matrices and center points.
    destroy_real_matrix(temp1, k, k);
    destroy_real_matrix(temp2, k, k);

    delete [] x_0;
    delete [] y_0;

    // Return our statistic.
    return stat;

}

//////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////// PERMUTATION TESTING /////////////////////////////////

// Performs a permutation test for the Procrustes statistic.
// Accepts:
//  int NUM_PERMUTATIONS -> The number of permutations to run.
//  double** X -> The first set of points.
//  double** Y -> The second set of points.
//  int n -> The number of points.
//  int k -> The dimension of each point.
//  double* t -> Sets the observed initial procrustes statistic, our t_0.
//  double* p_value -> Sets the p_value given by the permutation test.
//      Assumes 0 < k < n.
// Returns: void.
void permutation_test(int NUM_PERMUTATIONS, double** X, double** Y, int n, int k, double* t, double* p_value) {

    // First, we allocate all of the necessary memory and variables.

    // Create our temp matrices.
    double** temp1 = create_real_matrix(k, k);
    double** temp2 = create_real_matrix(k, k);

    // Create our arrays to hold the point centers.
    double* x_0 = new double[k];
    double* y_0 = new double[k];

    // Set each element equal to 0.
    for (int i = 0; i < k; i++) {
        x_0[i] = 0;
        y_0[i] = 0;
    }
    // Now, calculate the center.
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < k; j++) {
            x_0[j] += (X[i][j] / n);
            y_0[j] += (Y[i][j] / n);
        }
    }
    // Center the sets of points.
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < k; j++) {
            X[i][j] -= x_0[j];
            Y[i][j] -= y_0[j];
        }
    }

    // We need a copy of X to permute.
    double** permuteX = deep_copy_real_matrix(X, n, k);

    // Calculate our initial t value.
    double D = procrustes_statistic(X, Y, temp1, temp2, n, k);

    // Set our initial t.
    double t_0 = sqrt(1 - D);

    // Keep the count of observations with a value >= t_0.
    int count = 0;

    // Now do the permutation test.
    for (int i = 0; i < NUM_PERMUTATIONS; i++) {

        // Shuffle permuteX.
        shuffle_real_matrix(permuteX, n);
        
        // Do the analysis.
        D = procrustes_statistic(permuteX, Y, temp1, temp2, n, k);

        // See if it was significant.
        if ( t_0 <= sqrt(1 - D) ) {
            count++;
        }

    }

    // Uncenter the points.
    //  This is only needed if we want X and Y unchanged.
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < k; j++) {
            X[i][j] += x_0[j];
            Y[i][j] += y_0[j];
        }
    }

    // Free all the used memory.
    destroy_real_matrix(temp1, k, k);
    destroy_real_matrix(temp2, k, k);
    destroy_real_matrix(permuteX, n, k);
    delete [] x_0;
    delete [] y_0;

    // Set our initial t value.
    *t = t_0;

    // Finally, we set our p_value.
    *p_value = (count + 1.0) / (NUM_PERMUTATIONS + 1);

}

//////////////////////////////////////////////////////////////////////////////////////


// Our main method unit tests Procrustes Analysis.
int main() {

    // Seed the generator.
    srand((unsigned int) time(NULL));

    /*

    // Test 5 x 5 distance matrices.
    int n = 5;

    // Create matrices.
    double** A = create_real_matrix(n, n);
    double** B = create_real_matrix(n, n);

    // Fill A.
    A[0][0] = 1; A[0][1] = 2; A[0][2] = 3; A[0][3] = 4; A[0][4] = 5;
    A[1][0] = 2; A[1][1] = 1; A[1][2] = 2; A[1][3] = 3; A[1][4] = 4;
    A[2][0] = 3; A[2][1] = 2; A[2][2] = 1; A[2][3] = 2; A[2][4] = 3;
    A[3][0] = 4; A[3][1] = 3; A[3][2] = 2; A[3][3] = 1; A[3][4] = 2;
    A[4][0] = 5; A[4][1] = 4; A[4][2] = 3; A[4][3] = 2; A[4][4] = 1;

    // Fill B.
    B[0][0] = 1; B[0][1] = 2; B[0][2] = 6; B[0][3] = 9; B[0][4] = 11;
    B[1][0] = 2; B[1][1] = 1; B[1][2] = 3; B[1][3] = 7; B[1][4] = 10;
    B[2][0] = 6; B[2][1] = 3; B[2][2] = 1; B[2][3] = 4; B[2][4] = 8;
    B[3][0] = 9; B[3][1] = 7; B[3][2] = 4; B[3][3] = 1; B[3][4] = 5;
    B[4][0] = 11; B[4][1] = 10; B[4][2] = 8; B[4][3] = 5; B[4][4] = 1;

    // Print the contents of our matrices for convience.
    printf("\n");
    printf("Our A matrix:\n");
    print_real_matrix(A, n, n);
    printf("\n");

    printf("\n");
    printf("Our B matrix:\n");
    print_real_matrix(B, n, n);
    printf("\n");

    // Compute PCA for A and B for k = 1, 2, 3, 4
    double** a1 = distance_matrix_pca(A, n, 1);
    double** a2 = distance_matrix_pca(A, n, 2);
    double** a3 = distance_matrix_pca(A, n, 3);
    double** a4 = distance_matrix_pca(A, n, 4);
    double** b1 = distance_matrix_pca(B, n, 1);
    double** b2 = distance_matrix_pca(B, n, 2);
    double** b3 = distance_matrix_pca(B, n, 3);
    double** b4 = distance_matrix_pca(B, n, 4);

    // Print PCA for a_k and b_k for k = 1, 2, 3, 4
    printf("\n");
    printf("PCA on A with k = 1:\n");
    print_real_matrix(a1, n, 1);
    printf("\n");

    
    printf("\n");
    printf("PCA on A with k = 2:\n");
    print_real_matrix(a2, n, 2);
    printf("\n");

    printf("\n");
    printf("PCA on A with k = 3:\n");
    print_real_matrix(a3, n, 3);
    printf("\n");

    printf("\n");
    printf("PCA on A with k = 4:\n");
    print_real_matrix(a4, n, 4);
    printf("\n");

    printf("\n");
    printf("PCA on B with k = 1:\n");
    print_real_matrix(b1, n, 1);
    printf("\n");

    printf("\n");
    printf("PCA on B with k = 2:\n");
    print_real_matrix(b2, n, 2);
    printf("\n");

    printf("\n");
    printf("PCA on B with k = 3:\n");
    print_real_matrix(b3, n, 3);
    printf("\n");

    printf("\n");
    printf("PCA on B with k = 4:\n");
    print_real_matrix(b4, n, 4);
    printf("\n");

    double p1 = procrustes_analysis(a1, b1, n, 1);
    double p2 = procrustes_analysis(a2, b2, n, 2);
    double p3 = procrustes_analysis(a3, b3, n, 3);
    double p4 = procrustes_analysis(a4, b4, n, 4);

    printf("The Procrustes statistic between A and B with k = 1:\n");
    printf("%lf\n", p1);
    printf("\n");

    printf("The Procrustes statistic between A and B with k = 2:\n");
    printf("%lf\n", p2);
    printf("\n");

    printf("The Procrustes statistic between A and B with k = 3:\n");
    printf("%lf\n", p3);
    printf("\n");

    printf("The Procrustes statistic between A and B with k = 4:\n");
    printf("%lf\n", p4);
    printf("\n");
    
    // Destroy all free memory.
    destroy_real_matrix(A, n, n);
    destroy_real_matrix(B, n, n);
    destroy_real_matrix(a1, n, 1);
    destroy_real_matrix(a2, n, 2);
    destroy_real_matrix(a3, n, 3);
    destroy_real_matrix(a4, n, 4);
    destroy_real_matrix(b1, n, 1);
    destroy_real_matrix(b2, n, 2);
    destroy_real_matrix(b3, n, 3);
    destroy_real_matrix(b4, n, 4);

    */

    int n = 500;

    int k = 2;

    double** A = create_real_matrix(n, n);
    double** B = create_real_matrix(n, n);

    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (i == j) {
                A[i][j] = 1;
                B[i][j] = 1;
            }
            A[i][j] = A[j][i] = (rand() % 10);
            B[i][j] = B[j][i] = (rand() % 10);
        }
    }

    double** X = distance_matrix_pca(A, n, k);
    double** Y = distance_matrix_pca(B, n, k);

    double t, p;

    permutation_test(1000, X, Y, n, k, &t, &p);

    printf("P(t > t_0 = %lf) = %lf\n", t, p);

    destroy_real_matrix(A, n, n);
    destroy_real_matrix(B, n, n);
    destroy_real_matrix(X, n, k);
    destroy_real_matrix(Y, n, k);

}